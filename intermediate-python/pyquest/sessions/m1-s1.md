# Module 1 — OOP Foundations
## Session 1: World + Movement (Rooms, Player, Connections)

**Timebox:** 60–120 minutes  
**You write all code.** This document is the spec + acceptance criteria only.

---

## Goal
Build the *minimum playable core* of a text adventure:
- A world made of connected rooms
- A player that exists in exactly one room at a time
- Movement between rooms by direction
- A `look` output that proves state is correct

This session is intentionally small: it’s about **classes, attributes, methods, initialization, and object references**.

---

## Learning objectives (mapped to Week 1 topics)
- Model a domain using classes (Room, Player)
- Understand object references (rooms connected by holding references)
- Practice initialization rules (`__init__`)
- Work with “identity vs value” thinking (what is “the same room”?)

---

## Scope (what you must implement)
### Entities
1. **Room**
   - Has a **name**
   - Has **exits** (direction → room)
   - Can connect to other rooms

2. **Player**
   - Has a **name**
   - Has a **current_room**
   - Can move by direction

3. **World builder / setup**
   - A function or class that creates at least **3 rooms** and connects them
   - Spawns the player in a starting room

4. **Look**
   - A function or method that prints/returns:
     - current room name
     - available exits (directions)

---

## Required public behavior (interfaces)
You can choose file/module names, but your code must support these behaviors:

### Room behavior
- Create a room with a name.
- Add a connection to another room in a given direction.
- Ask a room what exits it has.
- Ask a room what room lies in a given direction (or get “no exit”).

### Player behavior
- Create a player with a name and starting room.
- Attempt to move by direction:
  - If exit exists: update location and return success
  - If exit does not exist: do not move, return failure

### Look behavior
- Given a player (or current room), produce a human-readable snapshot:
  - Room: <name>
  - Exits: <comma-separated directions> OR “none”

---

## Rules / constraints (important)
1. **No external libraries.** Standard library only.
2. **Directions must be normalized** (pick one approach and document it):
   - Either force lowercase on input, or validate strictly.
3. **Connection storage must be a mapping** (direction → Room reference).  
   This is the core OOP lesson: rooms “know” other rooms via references.
4. **Design decision log (required):**
   Create (or begin) a `README.md` for PyQuest and write down:
   - How you represent exits (dict? other?)
   - Whether connection is one-way or two-way by default
   - How you normalize directions

---

## Acceptance tests (manual)
Your implementation passes Session 1 if the following are true:

### A) World creation
- You can create at least **3 rooms** (e.g., “Hall”, “Kitchen”, “Garden”).
- At least **2 connections** exist such that the player can move through a small path.

### B) Movement correctness
- Starting room is correct after spawn.
- Moving via a valid exit changes `player.current_room`.
- Moving via an invalid direction:
  - Does NOT crash
  - Does NOT change `player.current_room`
  - Returns a failure signal (your choice: False, None, exception-free message, etc.)

### C) Look output
After spawn, calling `look` produces output that includes:
- The correct current room name
- A list of exits that matches the room’s exit map

---

## Demo requirements (what you will show me)
When you’re done, you should be able to run a short demo that shows:

1) Spawn + look  
2) Move to another room + look  
3) Attempt an invalid move + confirm room unchanged + look

**Minimum demo transcript (example format, not exact wording):**
- Room: Hall | Exits: north, east
- move north → success
- Room: Kitchen | Exits: south
- move west → fail (no exit)
- Room: Kitchen | Exits: south

---

## Stretch goals (optional, only if time remains)
- Add a `connect_two_way(room_a, dir_a_to_b, room_b, dir_b_to_a)` helper
- Make exits print in a stable order (e.g., sorted)
- Add a tiny pytest test for movement (optional)

---

## Commit suggestion
`pyquest: m1-s1 world + movement`

---

## Reflection (2 minutes)
Answer these in your PyQuest README (short bullets):
- What does it mean that exits store a *Room reference* and not a room name?
- What’s one bug you could create if you accidentally copy rooms instead of referencing them?

